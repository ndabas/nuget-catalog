{
  "@id": "https://api.nuget.org/v3/catalog0/data/2015.09.06.11.16.38/testfirst.net.0.3.4.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "TestFirst.Net",
  "catalog:commitId": "305e6d3d-efdc-4d8b-9dca-0469356753a9",
  "catalog:commitTimeStamp": "2015-09-06T11:16:38.915539Z",
  "copyright": "Copyright © TestFirst.Net 2014 - 2015",
  "created": "2015-09-06T11:15:56.883Z",
  "description": "Testing library providing a fluent tdd/bdd testing approach. Easily extended and integrated \ninto your own testing tools (nunit, xunit, moq, etc). \n\nEncourages the creation of easier to read and maintain testing code via the use of fluent builders for scenario's, given/when/thens, \nMoq verification, List and Dictionary matchers\n\nAvailable as via NuGet and compatible on both the Windows and Mono\n\nAs a quick example, the scenario:\n\n    \"Given a registered user, with an account balance of 10 dollars, when 6 dollars is debited, then \n    expect that the account only has 4 dollars, and the transaction ledger records a 6 dollar debit\"\n\ncan be written in TestFirst.Net as:\n\n    Scenario()\n        .Given(user = UserInTheDb().WithDefaults())\n        .Given(account = AccountInTheDb().For(user).Balance(10).Dollars())\n        \n        .When(()=>account.debit(6))\n\n        .Then(\n            ExpectThat(TheAccountInTheDb.For(account)),\n            Is(AnAcccount.With().Balance(4).Dollars())\n        .Then(\n            ExpectThat(TheAccountLedgerInTheDb.For(account)),\n            Is(AnLedger.With().Debit(6).Dollars());\n\n\nfor more info see project page",
  "iconUrl": "http://testfirstnet.github.io/TestFirst.Net/icon.png",
  "id": "TestFirst.Net",
  "isPrerelease": false,
  "lastEdited": "0001-01-01T00:00:00Z",
  "licenseNames": "",
  "licenseReportUrl": "",
  "licenseUrl": "http://testfirstnet.github.io/TestFirst.Net/LICENSE.txt",
  "listed": true,
  "packageHash": "8eMWuFn6iy2dOZydCR7vvfdbAVkoF1aftoxxDuAJH0r0H2hMbozCt5hjOs1cenpb49eDmSCwR8d9a6wGucs7hA==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 155553,
  "projectUrl": "https://github.com/TestFirstNet/TestFirst.Net/",
  "published": "2015-09-06T11:15:56.883Z",
  "releaseNotes": "TestFirst.Net\n============\n\n![TestFirst.Net](icon.png)\n\nTesting library providing a fluent tdd/bdd testing approach. Easily extended and integrated \ninto your own testing tools (nunit, xunit, moq, etc). \n\nEncourages the creation of easier to read and maintain testing code via the use of fluent builders for scenario's, given/when/thens, \nMoq verification, List and Dictionary matchers\n\nAvailable as via NuGet and compatible on both the Windows and Mono\n\nAs a quick example, the scenario:\n\n    \"Given a registered user, with an account balance of 10 dollars, when 6 dollars is debited, then \n    expect that the account only has 4 dollars, and the transaction ledger records a 6 dollar debit\"\n\ncan be written in TestFirst.Net as:\n\n    Scenario()\n        .Given(user = UserInTheDb().WithDefaults())\n        .Given(account = AccountInTheDb().For(user).Balance(10).Dollars())\n        \n        .When(()=›account.debit(6))\n\n        .Then(\n            ExpectThat(TheAccountInTheDb.For(account)),\n            Is(AnAcccount.With().Balance(4).Dollars())\n        .Then(\n            ExpectThat(TheAccountLedgerInTheDb.For(account)),\n            Is(AnLedger.With().Debit(6).Dollars());\n    \nWhich depending on the number of beers you've drunk resembles the natural english version fairly closely without the need for additional\ntemplate translation steps in the process (so refactoring won't kill things, find references still work, can step directly to the assertion code)    \n\nThe goals behind this library are:\n\nComprehension\n------------\n\n* tests should be easy to understand. Since code is read far more than written, focus on the read part.\n* keep tests as close to natural language as possible, though try to eliminate ambiguity\n* if possible also make tests easy to write. This results in more test code and more fun\n\nIntegration\n------------\n\n* don't get in the way of my existing tests\n* don't force (but maybe encourage) how I should write and integrate my test code\n* make integration easy\n\nMaking the IDE work for you\n------------\n   \n* support autocomplete.\n* support refactoring.\n* make it easy to jump directly to code doing the actual work.\n\nExtensibility\n------------\n        \n* make it easy to customise your tests.\n* infrastructure should aid not hinder.\n* allow you to do your own thing when required. Replace the bits you need without having to reimplement all the parts\n* not force you to do it a certain way, though encouraging conventions helps.\n\nDiscoverability\n------------\n\n* discovery of things should be easy without the need to go and read the documentation. \n* a consistent and easy to guess naming pattern.\n\nDiagnostics\n------------\n\nIf a test fails tell explain why and provide as much info as possible why it failed. Don't tell just say test failed,\nprovide as much information about what was expected and what was actually found along with any other related information.\n\nDRY\n------------\n\nDon't copy and paste the same boring assertion, or complex relationship assertion all through your tests. Put them \nin a single place (a Matcher). This makes changes to business behvaiour much easier to manage.\n\nMatchers\n============\n\nTestFirst.Net centers around the concept of a 'Matcher'. This is a class separate from your individual unit test to perform assertions\non the objects and services under test. Naming convention is that matchers names start with an 'A' or an 'An'\n\nExamples:\n\n    AString.Contains(...)\n    AnInt.Between(2,5)\n    ADateTime.Now().Within(3).Seconds()\n    ACookie.With().Name(\"foo\").Value(AString.MatchingAndPattern(\"?bar*)).Expires(ADateTime.After(DateTime.Now)));\n    AFoo.With().Bar(\"123\").Fibble(AFibble.With().BigEars().NoMoustache());\n\nThe idea is that as you flesh out your tests over time, more and more of the test code can be reused. This is\nversus all the assertions repeated in your test. So for example if there is a concept of a 'valid' email address, \nthere can be an email address matcher, or in combination with your user matcher you can call:\n\n    AUser.With().ValidEmail() under the hood might call 'AnEmailAddress.IsValid(...)'\n\nDitto for things like a valid user account, trade, registration etc\n\nAs more and more matchers are added over time, more of your tests can be written using existing matchers. If some\nconcept changes, in theory only a few locations in your test code need to also.\n\nRemember, auto complete is your friend! If you stick to the naming conventions, you only need to start typing \nand in theory completions should come up. \n\nThe static create method is usually 'With' for complex matchers, or simply the matcher method for simpler \nones. Sometimes 'Of' or 'For' are used if this aids in the fluent langauge\n\nThere are basic matchers for most of the primitive types, along for other base types. Simply hit 'A' and start typing. \nSome existing ones are 'AString', 'AnInt', 'ADecimal', 'ADateTime', 'AList','ADictionary', 'AnInstance'. Others are \nfor you to write for your own objects. The neat thing is this can then be reused across tests. \n\nThere is a code generator to generate matchers automatically for each of your objects. See the section on code generation.\n\nUsage\n============\n\nUsing just the assertions\n----------\n\nThis is useful if you only want to sprinkle your existing tests with a bit of TestFirst.Net\n\nExamples:\n\n    using TestFirst.Net;\n    using TestFirst.Net.Matcher;\n    using TestFirst.Net.Extensions.NUnit;\n    using ...\n\n    namespace ...\n\n    [TestFixture]\n    public class MyTest : AbstractNUnitScenarioTest\n    {\n        [Test ()]\n        public void TestSomething()\n        {\n\n            ...do stuff in your test\n\n            Expect\n                .That(foolist) ‹--thing we want to assert\n                .Is(AList.InAnyOrder().WithOnly(\"a\").And(\"b\")); ‹--'Matcher' we are using to perform the \n\n            Expect\n                .That(()=›foo.DoIt())\n                .Throws(AnException.Of().Type‹MyException›().Message(AString.ContainingIgnorePunctuationAndCase(\"Some bad thing\")));\n            \n            Expect\n                .That(()=›foo.map())\n                .Is(ADictionary\n                    .KeyMatching(\"a\",\"value_a\")\n                    .KeyMatching(\"foo\",AFoo.With().FloppyEars().SunHat()));\n        }\n    }\n    \n\nScenario based\n----------\n\nSetup scenarios which provide injection, db creation, db insertion and retrieval, service startup, resource cleanup. \n\nYou can still roll it as you wish by combining or swapping out the parts yourself. This still integrates with your existing test classes.\n\nIf extending for NUnit or Moq include the nuget package 'TestFirst.Net.Extensions'\n\n    using NUnit.Framework;\n    using TestFirst.Net;\n    using TestFirst.Net.Matcher;\n    using TestFirst.Net.Extensions.NUnit;\n    using ...\n    \n    namespace ...\n\n    [TestFixture]\n    public class MyTestScenario : AbstractNUnitScenarioTest {...//or AbstractNUnitMoqScenarioTest or ScenarioFluency\n\n        [Test]\n        public void HappyPathUserCorrectlyRegistered(){\n            RegistrationService service;\n            Registration reg;            \n\n            Scenario() ‹-- passes back a 'Scenario' object with an injector, uses the current test's name\n                .Given(reg = UserRegistration.With().Defaults().Age(123).RandomPassword()..)\n                .Given(service = NewRegistrationService())    ‹--this is disposed at end of test\n                .When(service.register(reg))//‹!--interesting part of test\n                .Then(\n                    ExpectThat(UserInTheDb.With().UserName(reg.UserName)), ‹-- UserInTheDb is a 'Fetcher'\n                    Is(AUserInTheDb.With().Age(reg.Age)...))\n                .Then(\n                    ExpectThat(LoginInTheDb.With().UserName(reg.UserName)),\n                    Is(ALoginInTheDb.With().Password(reg.Password)...))\n                .Then(\n                    ExpectThat(AccountInTheDb.With().UserName(reg.UserName)),\n                    Is(AnAccount.With().Created(ADateTime.After(now)...))\n\n        }\n    }\n\nTest now clearly shows the setup, the operation(s) we're testing, and the expected result\n\nThe 'XInTheDb', as in 'UserInTheDb' implements the 'IFetcher' interface. This simply is used to look things up (how you do it \nup to you). It will also have dependencies injected. Up to you to write or generate this class.\n\nThe 'Given', 'When', 'Then' methods are chained builder methods taking in a number of different parameter types. All objects\npassed in have their dependencies set via the IStepArgDependencyInjector. The default setup simply\ncollects all objects implementing 'IDisposable' and disposes of them in reverse order on test method exit.\n\nTo customise the scenario, call the various 'UseX...' methods before creating the scenario, as in:\n\n    UseScenarioInjector(myInjector);\n\n    Scenario()\n        ...\n\nFor custom injection for all tests simply create your own base test case which sets the various options in the call to 'Scenario',\nor implement 'OnBeforeNewScenario'    \n\nConstituent Parts\n============\n\nMatchers (IMatcher)\n----------\n\nAs mentioned previously, these are used to match results against\n\nFetchers  (IFetcher)\n----------\n\nThese fetch things given a set of criteria. They can be passed to a 'Then' method to find the object to assert on using \na given matcher. Simply implement a 'Fetch' method.\n\nInserters (IInserter)\n----------\n\nThese insert things. What they insert into what is up to you. They simply implement an 'Insert' method. Disabled if\nrunning tests against a prod database\n\nUpdaters (IUpdater)\n----------\n\nPerform cleanup,delete or update stuff. Implements, you guessed it, 'Update'.\n\nInvokers (IInvokable)\n----------\n\nDo something when passed to 'Given','When','Then'. Implements 'Invoke'\n\nBuilders (IBuilder)\n----------\n\nAnything passed to 'Given','When','Then' which is a builder will have it's 'Build' method called. This allows for building\nup complex test state in an easy to read way. Builders also have depedencies injected.\n    \nDependency injector (IStepArgDependencyInjector)\n----------\n\nAll the objects passed to 'Given', 'When', 'Then' are passed through this injector to have dependencies set. \n\nUtilities\n============\n\n\nTestFirst.Net.Rand.Random\n----------\n\nA more useful random value generator.\n\nExample:\n\n    var rand = new Random();\n    foo.setName(rand.AlphaNumericString(7)).setMyEnum(rand.EnumOf‹MyEnum›());\n        \n\nTestFirst.Net.Rand.RandomFiller\n----------    \n\nTo fill poco's with random data.\n\nExample:\n\n    var filler = new RandomFiller.With()\n        .GeneratorForType(typeof(Fibble), () =› Fibble.CreateRandom()) //customise random value generators\n        .EnableLogging(true)\n        .Build();\n\n    var poco = filler.FillWithRandom(new MyPoco());//do the actual filling\n\nMoq Scenario\n============\n\nInclude nuget package TestFirst.Net.Extensions\n\nExtend AbstractNUnitMoqScenarioTest to provide easy creation and registration of Moq mocks.\n\nIf using MatcherMoqExtensions, a fullish example would be:\n    \n    using TestFirst.Net;\n    using TestFirst.Net.Matcher;\n    using TestFirst.Net.Extensions.Moq;\n    using ...\n    \n    namespace ...\n    \n    [TestFixture]\n    public class MyTestClass : AbstractNUnitMoqScenarioTest {\n\n        [Test]\n        public void myTest(){\n         \n            MyClass foo;\n            String response;\n\n            Scenario() //this will set the scenario name to the name of your test method, in this case 'myTest'\n                 .Given(foo=AMock‹MyClass›() //setup the mock\n                         .WhereMethod(f=›f.DoIt(\n                             ArgIs(AString.EndingWith(\"It\")),\n                             ArgIs(AnInt.GreaterThan(0))\n                         )\n                         .Returns(\"done!\")\n                         .WhereMethod(f=›f.DoneIt(\n                             ArgIs(AString.EqualTo(\"done!\"))\n                         )\n                         .Instance //returns the mock object and assigns to foo\n                 )\n             .When(response=foo.DoIt(\"WorkIt\",2)) //invoke the 1st method\n             .Then(ExpectThat(response),Is(AString.EqualTo(\"done!\"))\n             .When(foo.DoneIt(response)) //invoke the 2nd method\n             .Then(Nothing())//you shoud assert something here\n\n            //Moq's Mock.VerifyAll will be automatically called at the end of the scenario\n        }\n    }\n\nPerformance testing\n============\n\nInclude nuget package TestFirst.Net.Performance\n\nExample:\n\n    using TestFirst.Net;\n    using TestFirst.Net.Matcher;\n    using TestFirst.Net.Extensions.NUnit;\n    using TestFirst.Net.Performance;\n    using ...\n\n    namespace ...\n    \n    [TestFixture]\n    public class MyPerfTest:AbstractNUnitScenarioTest\n    {\n        [Test]        \n        public void WhateverPerfTest()\n        {\n            PerformanceMetricsWriter metricsWriter;\n            PerformanceReport report;\n\n            Scenario()\n                .Given(metricsWriter = PerformanceMetricsWriter.With().TestName(\"WhateverPerfTest\"))\n                .When(PerformanceSuite.With()\n                    .NumRuns(2)\n                    .PerRunTimeout(20).Seconds()\n                    .LoadRunner(ContentionLoadRunner.With()\n                        .Tests(new MyPerfTest()) //the test to run\n                        .RunTimeout(15).Seconds())\n                    .Listener(metricsWriter)\n                    .Build())//runs the test (returns an IInvokable)\n                .When(report = metricsWriter.BuildReport())//no magic, just assignment\n                .When(report.PrintToConsole)//just an action, nothing magic\n                .Then(\n                    Expect(report.GetMetricSummaryNamed(\"metric1\").ValueMean),\n                    Is(ADouble.EqualTo(4.75)))\n                .Then(\n                    Expect(report.GetMetricSummaryNamed(\"metric1\").ValueMedian),\n                    Is(ADouble.EqualTo(5)))\n                 .Then(\n                    Expect(report.GetMetricSummaryNamed(\"metric1\").ValueMax),\n                    Is(ADouble.EqualTo(10)))\n                 .Then(\n                    Expect(report.GetMetricSummaryNamed(\"metric1\").ValueMin),\n                    Is(ADouble.EqualTo(0)))\n                 .Then(\n                    Expect(report.GetMetricSummaryNamed(\"metric1\").MetricName),\n                    Is(AString.EqualTo(\"metric1\")));\n        }\n\n    ...\n    }   \n\nAny part of the above can be replaced with your own implementation if you don't like how the provided classes work.\n\nOutput report will look something like:\n\n    Generated At: XXXX\n         Metrics: \"‹path-to-results›.csv\"\n         Summary:\n    For metric 'metric1'\n            Total Metric Count: 10\n                      Ok Count: 8\n                   Error Count: 2 (ignored in calculations)\n             Throughput/Second: 8\n                  Metric Units: ms\n                       Min Val: 0\n                      Mean Val: 4.75\n                    Median Val: 5\n                       Max Val: 10\n                  StdDeviation: 3.56195171219375\n        StdDeviation % of Mean: 74.9884570988158%\n       68% confidence interval (+/-1 std deviation)\n                              : 1.18804828780625 to 8.31195171219375\n       95% confidence interval (+/-2 std deviations)\n                              : -2.3739034243875 to 11.8739034243875\n    For metric 'metric2'\n        .....\n\n\nAutomatic Matcher code generation\n============\n\nIn a T4 template, use the following:\n\n\n    var template = new MatchersTemplate();\n\n    //customise generation\n    template.ForPropertyType‹String›()\n        .AddMatchMethodTaking‹int›(\"$argName.ToString()\");‹--for any String property, add a match method taking an int\n    \n    //genrate matchers for the following\n    template.GenerateFor‹MyPoco›();\n    template.GenerateFor‹MyPoco2›().MatcherName(\"MyFibble\");//customise matcher name\n    template.GenerateFor‹MyPoco3›().MatcherName(\"MyFrubble\").ExcludeProperties(\"MyExcludedProp\");//further customisation\n    \n    template.RenderToFile(\"MyMatchers.cs\");‹--will write all the generated matchers to the given file\n    \nBuilding\n=============\n\nThis library is built and tested on mono. It uses Nuget and xbuild. In visual studio it should 'just' build.\n\nTo build and test from  the command line (bash), run the build script:\n\n    ./build clean build test\n\nFor further options run:\n\n    ./build help\n\nContributing\n============\n\nUpdates and suggestions welcome and actively encouraged. Bug fixes, improvements, better documention, more tests, yes yes and yes!\n\nWill accept email diffs (if not massive) if you want to protect your identity (e.g. corporate).\n\nPreference is for pull requests though.\n\nPrefer many smaller changes rather than a massive refactor (will then likely reject). Try to keep a patch focused on one aspect. If \nmultiple changes try to stagger in a sensible way so each step can be tested along the way.\n\nTODO\n===========\n\n* Flesh out examples\n* More documentation\n* Flesh out public database testing code\n* Add base UI testing",
  "requireLicenseAcceptance": false,
  "title": "TestFirst.Net",
  "verbatimVersion": "0.3.4",
  "version": "0.3.4",
  "tags": [
    "testing",
    "tdd",
    "bdd",
    "fluent",
    "nunit",
    "moq"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}