{
  "@id": "https://api.nuget.org/v3/catalog0/data/2015.06.11.20.37.47/languageext.1.0.0.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "Paul Louth",
  "catalog:commitId": "f4baba46-3016-419c-8028-695fce2eb755",
  "catalog:commitTimeStamp": "2015-06-11T20:37:47.98172Z",
  "copyright": "Paul Louth 2015",
  "created": "2015-06-11T20:37:10.833Z",
  "description": "Use and abuse the features of C#, which, if you squint, can look like extensions to the language itself.  This package is a functional 'toolkit' and also solves some of the annoyances with C#, namely:\n\n            * Poor tuple support\n            * Null reference problem\n            * Lack of lambda and expression inference\n            * Void isn't a real type\n            * Mutable lists, dictionaries, sets, queues, etc.\n            * The awful 'out' parameter\n\n        The library very heavily focusses on correctness, to give you the tools needed to write safe declarative code.\n\n        Features:\n\n            Powerful 'prelude' which you include by `using static LanguageExt.Prelude` (in C# 6) that covers many of the basic functional language core library functions and types (from `using LanguageExt`):\n\n                Pattern matching\n                Lambda type-inference: `var fn = fun( (int x, int y) => x + y );`\n                `Option<T>`, `OptionUnsafe<T>`, `Either<L,R>`, `EitherUnsafe<L,R>` and `TryOption<T>` monads (probably the most complete implementations you'll find in the .NET world)\n                `tuple(a,b,...)` - `Tuple` construction without typing `Tuple.Create(a,b,...)` as well as `map` to project the `Item1..ItemN` properties onto named values.\n                `List` - immutable list \n                `Map` - immutable map                                                \n                `Set` - immutable set\n                `memo` - Memoization with auto-cache purging using weak-references\n                `Writer` monad\n                `Reader` monad\n                `State` monad\n                Extension methods and replacement functions for dealing with `out` (Int32.TryParse, IDictionary.TryGetValue, etc.)",
  "frameworkAssemblyGroup": {
    "@id": "https://api.nuget.org/v3/catalog0/data/2015.06.11.20.37.47/languageext.1.0.0.json#frameworkassemblygroup",
    "assembly": "System"
  },
  "iconUrl": "http://www.4four.org/images/lang-ext-logo.png",
  "id": "LanguageExt",
  "isPrerelease": false,
  "lastEdited": "0001-01-01T00:00:00Z",
  "licenseUrl": "https://github.com/louthy/language-ext/blob/master/LICENSE.md",
  "packageHash": "VtkLxB5Mgb71JZL7mF1+Axr7VpkOdpwr5v6W/Bno/3ZZxOrqTIZRnxakPPUbWBhYUQKnwMF06QifGiAWPo5hfQ==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 68991,
  "projectUrl": "https://github.com/louthy/language-ext",
  "published": "2015-06-11T20:37:10.833Z",
  "releaseNotes": "Now that System.Collections.Immutable has been fully released (as version 1.1.36) we can now do a full release of Language-ext.  \n\n            So here is version 1.0.0!\n\n            Additions:\n                New `Reader<E,T>` monad\n                    `Prelude.Reader` constructor function\n                    `Prelude.ask` function\n                    `Prelude.local` function\n                New `Writer<W,T>` monad    \n                    `Prelude.Writer` constructor function\n                    `Prelude.tell` function\n                New `State<S,T>` monad\n                    `Prelude.State` constructor function\n                    `Prelude.get` function\n                    `Prelude.put` function\n                `Option<T>`\n                    `IfSome` method for dispatching actions and ignoring `None`\n                    `Prelude.ifSome` as above\n                    `IfNone` method (replaces `Failure`)\n                    `Prelude.ifNone` function (replaces `Prelude.failure`)\n                    `ToEither` converts an `Option<T>` to an `Either<L,T>` (you must provide a default(L) value or func incase the Option is in a None state)\n                    `ToEitherUnsafe` converts an `Option<T>` to an `EitherUnsafe<L,T>` (you must provide a default(L) value or func incase the Option is in a None state)\n                    `Some` fluent method now also supports `Action`\n                `OptionUnsafe<T>`\n                    `IfSomeUnsafe` method for dispatching actions and ignoring `None` \n                    `Prelude.ifSomeUnsafe` as above\n                    `IfNoneUnsafe` method (replaces `FailureUnsafe`)\n                    `Prelude.ifNoneUnsafe` function (replaces `Prelude.failureUnsafe`)\n                    `ToEitherUnsafe` converts an `OptionUnsafe<T>` to an `EitherUnsafe<L,T>` (you must provide a default(L) value or func incase the OptionUnsafe is in a None state)\n                    `Some` fluent method now also supports `Action`\n                `TryOption<T>`\n                    `IfSome` method for dispatching actions and ignoring `None` or `Fail`\n                    `Prelude.ifSome` as above\n                    `IfNone` method (replaces `Failure`)\n                    `Prelude.ifNone` function (replaces `Prelude.failure`)\n                    `IfNoneOrFail` method for handling both failure states separately (Some state uses identity function)\n                    `Prelude.ifNoneOrFail` as above\n                    `TryOptionConfig.ErrorLogger` static variable which can be used to attach error logging behaviour to the `Fail` state of `TryOption`\n                    `Prelude.tryfun` function wraps a `TryOption` in a `Func`\n                    `ToOption` converts a `TryOption<T>` to a `Option<T>` (Fail becomes None)\n                    `Some` fluent method now also supports `Action`\n                `Either<L,R>`\n                    `IfRight` method for dispatching actions and ignoring `Left`\n                    `Prelude.ifRight` as above\n                    `IfLeft` method (replaces `Failure`)\n                    `Prelude.ifLeft` method (replaces `Prelude.failure`)\n                    `Right` fluent method now also supports `Action`\n                    `ToOption` converts an `Either<L,R>` to an `Option<R>` (L becomes None)\n                    `ToTryOption` converts an `Either<L,R>` to a `TryOption<R>`\n                    `ToEitherUnsafe` converts an `Either<L,R>` to an `EitherUnsafe<L,R>` (L becomes None)\n                `EitherUnsafe<L,R>`\n                    `IfRightUnsafe` method for dispatching actions and ignoring `Left`\n                    `Prelude.ifRightUnsafe` as above\n                    `IfLeftUnsafe` method (replaces `FailureUnsafe`)\n                    `Prelude.ifLeftUnsafe` method (replaces `Prelude.failureUnsafe`)\n                    `Right` fluent method now also supports `Action`\n\n            Updates:\n                `Prelude.convert<T>` now returns `None` if input is `null` (it previously threw an exception)\n\n            Fixes:\n                Query.zip would go into an infinite loop. Fixed.\n                Comments\n\n            Deprecated:\n                Dependency on ConcurrentHashTable\n                `failure` and `Failure` (for `ifNone`, `IfNone`, `ifLeft`, etc.)\n                Iter extension method in Query, it was causing resolution problems for the compiler.\n                Removed `RightUnsafe` and `LeftUnsafe` from `Either`, these were a hangover from when `EitherUnsafe` didn't exist and `Either` had a dual role.  This isn't needed any more.",
  "requireLicenseAcceptance": false,
  "summary": "",
  "title": "C# Functional Language Extensions",
  "version": "1.0.0",
  "dependencyGroups": [
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2015.06.11.20.37.47/languageext.1.0.0.json#dependencygroup/.netframework4.5",
      "@type": "PackageDependencyGroup",
      "dependencies": [
        {
          "@id": "https://api.nuget.org/v3/catalog0/data/2015.06.11.20.37.47/languageext.1.0.0.json#dependencygroup/.netframework4.5/system.collections.immutable",
          "@type": "PackageDependency",
          "id": "System.Collections.Immutable",
          "range": "[1.1.36, )"
        }
      ],
      "targetFramework": ".NETFramework4.5"
    }
  ],
  "tags": [
    "C#",
    "Functional",
    "Language",
    "Extension",
    "Monad",
    "Option",
    "Either",
    "Reader",
    "Writer",
    "State",
    "List",
    "Set",
    "Map",
    "Queue",
    "Memo",
    "Memoization",
    "Immutable",
    "Lambda",
    "Pattern",
    "Matching",
    "Tuple"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}