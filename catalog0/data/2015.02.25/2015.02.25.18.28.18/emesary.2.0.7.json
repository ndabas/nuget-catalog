{
  "@id": "https://api.nuget.org/v3/catalog0/data/2015.02.25.18.28.18/emesary.2.0.7.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "Richard Harrison",
  "catalog:commitId": "5b1a2fe6-ab8a-423f-99f0-144cf207d5cc",
  "catalog:commitTimeStamp": "2015-02-25T18:28:18.7790532Z",
  "copyright": "Richard Harrison",
  "created": "2015-02-25T18:27:21.983Z",
  "description": "The basic premise of the Emesary messaging system is to allow the decoupled operation of the various components that comprise any system - usually within the same process. \n\nThe basic unit of communication is a Notification, which is passed around to any and or all objects that implement the IReceive interface. Using Interfaces and ihneritance it is possible to pass around Notifications that have special meanings to certain objects and allow them to perform the appropriate function.\n\nIn our design Notifications are created and sent via a call to NotifyAll. Any object within the system can implement the IReceive interface and register itself with either a Queue (WIP) or a Transmitter to receive all notifications that are sent out. The underlying concept is that one part of a system knows that something needs to be done without needing to know how to do it. The part of the system that needs something done simply creates a notification and sends it out. Once received by the part of the system that is capable of performing the requested Notification the relevant actions will be carried out and a status of OK or Finished returned. See the section on return codes for a complete explanation of these codes and what they mean.\n\nref. http://chateau-logic.com/content/c-wpf-application-plumbing-using-emesary",
  "id": "Emesary",
  "isPrerelease": false,
  "lastEdited": "0001-01-01T00:00:00Z",
  "minClientVersion": "2.0.7",
  "packageHash": "A+/OQr8Ak8xEqQsnvz6d24aLPMuACqaKw+v304DkOShq/NaX18y/5fpDTDY+wpK42b5q4e+aa+wlcQ4z1viDrA==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 15776,
  "projectUrl": "https://emesary.codeplex.com/",
  "published": "2015-02-25T18:27:21.983Z",
  "releaseNotes": "2.0.7 Fix lockout after to catch all exceptions and handle the interlocked decrement; otherwise an exception in a recipient causes all future addition/remove to not work correctly\n2.0.5 Fix inheritnace problem whereby QueuedTransmitter replaced the NotifyAll which was wrong.\n\n2.0.4 Added missing event unlatch\n\n2.0.3 Fix bug in delayed add; to permit concurrency we only add new receivers after messages processed, however the test was wrong.\n\nAdded an AutoResetEvent onto the queue to allow better and more efficient thread processing.",
  "requireLicenseAcceptance": false,
  "summary": "Simple quick and efficient class based interobject communcation to allow decoupled disparate parts of a system to function together without knowing about each, e.g GUI, DB and business logic.",
  "title": "Interobject communication and application messaging",
  "version": "2.0.7",
  "tags": [
    "Events",
    "Messaging"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}