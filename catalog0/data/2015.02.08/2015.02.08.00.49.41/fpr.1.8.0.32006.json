{
  "@id": "https://api.nuget.org/v3/catalog0/data/2015.02.08.00.49.41/fpr.1.8.0.32006.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "eric_swann",
  "catalog:commitId": "69b07440-3253-4638-af94-5b0fa3e4de16",
  "catalog:commitTimeStamp": "2015-02-08T00:49:41.0411269Z",
  "copyright": "Copyright 2014 Eric Swann, et. al. - All rights reserved.",
  "created": "2014-07-27T23:46:53.133Z",
  "description": "A fast, fun and stimulating object to object mapper.  Kind of like AutoMapper, just simpler and way, way faster.",
  "iconUrl": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Paddleball.svg/202px-Paddleball.svg.png",
  "id": "Fpr",
  "isPrerelease": false,
  "language": "",
  "lastEdited": "2014-07-27T23:59:31.397Z",
  "packageHash": "+gYE2Ue79l+upDen6O300w4gD1zn3imavFwHrAyBS08PZVOOq1cYgVMh1cmAKM22DfwU3RmxrOlweS6kcraw9Q==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 62875,
  "projectUrl": "https://github.com/eswann/Fpr",
  "published": "2014-07-27T23:46:53.133Z",
  "releaseNotes": "Added support for custom type resolvers and custom value resolvers.  Also obsoleted IgnoreMember and MapFrom in favor of the more terse Ignore and Map.\n\nCustom Type Resolvers\n\nIn some cases, you may want to have complete control over how an object is mapped. In this case, you can register a custom type resolver. It's important to note that when using a custom type resolver, that all other mapping associated with the type is ignored. So all mapping must take place within the resolver. The custom type resolver must implement the ITypeResolver interface and register it using MapWith().\n\n//Example using MapWith resolver generic call.\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .MapWith<TCustomTypeResolver>();\n\n//Example using MapWith resolver factory function\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .MapWith(() => new TCustomTypeResolver());\n\n//Example using MapWith resolver instance\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .MapWith(customResolverInstance);\nCustom Value Resolvers\n\nIn some cases, you may want to encapsulate a value conversion into a separate class. In this case, you can use a custom value resolver by registering it using Resolve(). The value resolver must implement the IValueResolver interface.\n\n//Example using MapWith resolver generic call.\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .Resolve<TCustomValueResolver, string>(dest => dest.Name);\n\n//Example using value resolver factory function\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .Resolve(dest => dest.Name, () => new TCustomValueResolver());\n\n//Example using value resolver instance\nTypeAdapterConfig<TSource, TDestination>.NewConfig()\n            .Resolve(dest => dest.Name, customValueResolver);",
  "requireLicenseAcceptance": false,
  "summary": "A fast, fun and stimulating object to object mapper.  Kind of like AutoMapper, but simpler and way faster.",
  "title": "Fpr Mapper",
  "version": "1.8.0.32006",
  "tags": [
    "Mapper",
    "AutoMapper",
    "Fast",
    "Mapping"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}