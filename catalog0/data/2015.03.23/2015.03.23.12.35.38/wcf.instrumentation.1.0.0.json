{
  "@id": "https://api.nuget.org/v3/catalog0/data/2015.03.23.12.35.38/wcf.instrumentation.1.0.0.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "Chad Chambers",
  "catalog:commitId": "2a952af2-e299-4067-8a2a-fd9663d6dde2",
  "catalog:commitTimeStamp": "2015-03-23T12:35:38.4141787Z",
  "created": "2015-03-23T11:25:05.873Z",
  "description": "Instrumentation is provided using the event provider model. Events are notifications which you receive from the WCF application which can be a security event like password change, UI click events, or exception events like application level errors. These events are captured by the provider and routed to some source like event viewer, SQL Server, etc.",
  "id": "WCF.Instrumentation",
  "isPrerelease": false,
  "language": "en-ZA",
  "lastEdited": "2015-03-23T12:35:07.98Z",
  "packageHash": "IdcLezNCz8WeDNBGyKfDfaLc6qqrcSYv+gtfptNd+PYYqVcEtxgpyUOcPY4rn0EBZkTNmFCvImTN3OWFqLHxvQ==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 6405,
  "published": "2015-03-23T11:25:05.873Z",
  "releaseNotes": "How to implement:\n\nIn your service contract implement the health audit functionality\n\n  [ServiceContract]\n    public interface IService\n    {\n        [OperationContract]\n        string Audit();\n    }\n\nIn the Service.svc.cs class, implement the Audit function by creating the CustomAudit object and calling the Raise function\n\npublic class Service : IService\n{\n    public string Audit()\n    {\n        Healthmonitering.CustomAudit webevent = \n                                new Healthmonitering.CustomAudit(\"Some on called\", \n                    this, WebEventCodes.WebExtendedBase + 1);\n        webevent.Raise();\n        return \"Event Audited\";\n    }\n}\n\nIn the web.config and under system.web element, add a healthmonitoring tag.\nSpecify CustomAudit class in the eventMappings element and mapping of the class with event viewer in the rules element tag\n\n<healthMonitoring>\n<eventMappings>\n<add name=\"healthmonitering\" type=\"Healthmonitering.CustomAudit \"/>\n</eventMappings>\n<rules>\n<add name=\"healthmonitering\" eventName=\"healthmonitering\" \n                provider=\"EventLogProvider\" minInterval=\"00:00:01\"/>\n</rules>\n</healthMonitoring>\n\n\nFinally, consume the client service and call the Audit function in the button click event\n\nprotected void Button_Click(object sender, EventArgs e)\n{\n    ServiceReference1.Service1Client proxy = \n                                new WebApplication1.ServiceReference1.Service1Client();\n    string result = proxy.Audit();\n    Response.Write(result);\n}\n\nEnd result will be captured in the event logs like:\n\n***************start health monitoring event*******************\nmessage created at:Event Created at :3/23/2015 11:32:37 AM\nmessage raised at:Event Created at :3/23/2015 11:32:37 AM\nHeap size 2584335\nNumber of threads 14\nNumber of Working sets 32165888\nNumber of domains 1\nRequest rejected 0\n******************End Health Monitoring event*********************\n",
  "requireLicenseAcceptance": false,
  "summary": "Monitor events of WCF application events like errors, security audits, performance by extending the ASP.NET health monitoring system in WCF",
  "title": "WCF Instrumentation",
  "version": "1.0.0",
  "tags": [
    "WCF",
    "Instrumentation"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}