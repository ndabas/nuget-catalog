{
  "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "Akka.NET Team",
  "catalog:commitId": "c0ca6a87-051f-47d8-b390-6d47ff184f32",
  "catalog:commitTimeStamp": "2022-12-16T13:12:37.9252275Z",
  "copyright": "Copyright Â© 2013-2015 Akka.NET Team",
  "created": "2015-04-09T22:31:11.807Z",
  "deprecation": {
    "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#deprecation",
    "alternatePackage": {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#deprecation/alternatePackage",
      "id": "Akka.DependencyInjection",
      "range": "*"
    },
    "reasons": [
      "Legacy"
    ]
  },
  "description": "CastleWindsor Dependency Injection (DI) support for Akka.NET",
  "iconUrl": "https://raw.githubusercontent.com/akkadotnet/akka.net/gh-pages/images/icon-32x32.png",
  "id": "Akka.DI.CastleWindsor",
  "isPrerelease": false,
  "lastEdited": "2022-12-16T13:12:05.573Z",
  "licenseUrl": "https://github.com/akkadotnet/akka.net/blob/master/LICENSE",
  "listed": true,
  "packageHash": "QqADLsjDDaFwnFNGuYLSYeWMbC1W+C41+2tiOGlOrdoQ9ZyOi6eTALLkm/ggH/wlLHS7Yux/c7cStNgVHzQ2Kw==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 21333,
  "projectUrl": "https://github.com/akkadotnet/akka.net",
  "published": "2015-04-09T22:31:11.807Z",
  "releaseNotes": "Akka.NET is officially no longer in beta status**. The APIs introduced in Akka.NET v1.0 will enjoy long-term support from the Akka.NET development team and all of its professional support partners.\nMany breaking changes were introduced between v0.8 and v1.0 in order to provide better future extensibility and flexibility for Akka.NET, and we will outline the major changes in detail in these release notes.\nHowever, if you want full API documentation we recommend going to the following:\n[Latest Stable Akka.NET API Docs](http://api.getakka.net/docs/stable/index.html \"Akka.NET Latest Stable API Docs\")**\n[Akka.NET Wiki](http://getakka.net/wiki/ \"Akka.NET Wiki\")**\n----\nUpdated Packages with 1.0 Stable Release**\nAll of the following NuGet packages have been upgraded to 1.0 for stable release:\n- Akka.NET Core\n- Akka.FSharp\n- Akka.Remote\n- Akka.TestKit\n- Akka.DI (dependency injection)\n- Akka.Loggers (logging)\nThe following packages (and modules dependent on them) are still in *pre-release* status:\n- Akka.Cluster\n- Akka.Persistence\n----\nIntroducing Full Mono Support for Akka.NET**\nOne of the biggest changes in Akka.NET v1.0 is the introduction of full Mono support across all modules; we even have [Raspberry PI machines talking to laptops over Akka.Remote](https://twitter.com/AkkaDotNET/status/584109606714093568)!\nWe've tested everything using Mono v3.12.1 across OS X and Ubuntu.\n[Please let us know how well Akka.NET + Mono runs on your environment](https://github.com/akkadotnet/akka.net/issues/694)!**\n----\nAPI Changes in v1.0**\nAll methods returning an `ActorRef` now return `IActorRef`**\nThis is the most significant breaking change introduced in AKka.NET v1.0. Rather than returning the `ActorRef` abstract base class from all of the `ActorOf`, `Sender` and other methods we now return an instance of the `IActorRef` interface instead.\nThis was done in order to guarantee greater future extensibility without additional breaking changes, so we decided to pay off that technical debt now that we're supporting these APIs long-term.\nHere's the set of breaking changes you need to be aware of:\n- Renamed:\n- `ActorRef`          --> `IActorRef`\n- `ActorRef.Nobody`   --> `ActorRefs.Nobody`\n- `ActorRef.NoSender` --> `ActorRefs.NoSender`\n- `ActorRef`'s  operators `==` and `!=` has been removed. This means all expressions like `actorRef1 == actorRef2` must be replaced with `Equals(actorRef1, actorRef2)`\n- `Tell(object message)`, i.e. the implicit sender overload, has been moved\nto an extension method, and requires `using Akka.Actor;` to be accessible.\n- Implicit cast from `ActorRef` to `Routee` has been replaced with `Routee.FromActorRef(actorRef)`\n`async` / `await` Support**\n`ReceiveActor`s now support Async/Await out of the box.\n```csharp\npublic class MyActor : ReceiveActor\n{\npublic MyActor()\n{\nReceive<SomeMessage>(async some => {\n//we can now safely use await inside this receive handler\nawait SomeAsyncIO(some.Data);\nSender.Tell(new EverythingIsAllOK());\n});\n}\n}\n```\nIt is also possible to specify the behavior for the async handler, using `AsyncBehavior.Suspend` and  `AsyncBehavior.Reentrant` as the first argument.\nWhen using `Suspend` the normal actor semantics will be preserved, the actor will not be able to process any new messages until the current async operation is completed.\nWhile using `Reentrant` will allow the actor to multiplex messages during the `await` period.\nThis does not mean that messages are processed in parallel, we still stay true to \"one message at a time\", but each await continuation will be piped back to the actor as a message and continue under the actors concurrency constraint.\nHowever, `PipeTo` pattern is still the preferred way to perform async operations inside an actor, as it is more explicit and clearly states what is going on.\nSwitchable Behaviors**\nIn order to make the switchable behavior APIs more understandable for both `UntypedActor` and `ReceiveActor` we've updated the methods to the following:\n``` C#\nBecome(newHandler); // become newHandler, without adding previous behavior to the stack (default)\nBecomeStacked(newHandler); // become newHandler, without adding previous behavior to the stack (default)\nUnbecomeStacked(); //revert to the previous behavior in the stack\n```\nThe underlying behavior-switching implementation hasn't changed at all - only the names of the methods.\nScheduler APIs**\nThe `Context.System.Scheduler` API has been overhauled to be both more extensible and understandable going forward. All of the previous capabilities for the `Scheduler` are still available, only in different packaging than they were before.\nHere are the new APIs:\n``` C#\nContext.System.Scheduler\n.ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, ActorRef sender);\n.ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, ActorRef sender, ICancelable cancelable);\n.ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, ActorRef sender);\n.ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, ActorRef sender, ICancelable cancelable);\nContext.System.Scheduler.Advanced\n.ScheduleOnce(TimeSpan delay, Action action);\n.ScheduleOnce(TimeSpan delay, Action action, ICancelable cancelable);\n.ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action);\n.ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action, ICancelable cancelable);\n```\nThere's also a set of extension methods for specifying delays and intervals in milliseconds as well as methods for all four variants (`ScheduleTellOnceCancelable`, `ScheduleTellRepeatedlyCancelable`, `ScheduleOnceCancelable`, `ScheduleRepeatedlyCancelable`) that creates a cancelable, schedules, and returns the cancelable.\nAkka.NET `Config` now loaded automatically from App.config and Web.config**\nIn previous versions Akka.NET users had to do the following to load Akka.NET HOCON configuration sections from App.config or Web.config:\n```csharp\nvar section = (AkkaConfigurationSection)ConfigurationManager.GetSection(\"akka\");\nvar config = section.AkkaConfig;\nvar actorSystem = ActorSystem.Create(\"MySystem\", config);\n```\nAs of Akka.NET v1.0 this is now done for you automatically:\n```csharp\nvar actorSystem = ActorSystem.Create(\"MySystem\"); //automatically loads App/Web.config, if any\n```\nDispatchers**\nAkka.NET v1.0 introduces the `ForkJoinDispatcher` as well as general purpose dispatcher re-use.\nUsing ForkJoinDispatcher**\nForkJoinDispatcher is special - it uses [`Helios.Concurrency.DedicatedThreadPool`](https://github.com/helios-io/DedicatedThreadPool) to create a dedicated set of threads for the exclusive use of the actors configured to use a particular `ForkJoinDispatcher` instance. All of the remoting actors depend on the `default-remote-dispatcher` for instance.\nHere's how you can create your own ForkJoinDispatcher instances via Config:\n```\nmyapp{\nmy-forkjoin-dispatcher{\ntype = ForkJoinDispatcher\nthroughput = 100\ndedicated-thread-pool{ #settings for Helios.DedicatedThreadPool\nthread-count = 3 #number of threads\n#deadlock-timeout = 3s #optional timeout for deadlock detection\nthreadtype = background #values can be \"background\" or \"foreground\"\n}\n}\n}\n}\n```\nYou can then use this specific `ForkJoinDispatcher` instance by configuring specific actors to use it, whether it's via config or the fluent interface on `Props`:\nConfig**\n```\nakka.actor.deploy{\n/myActor1{\ndispatcher = myapp.my-forkjoin-dispatcher\n}\n}\n```\nProps**\n```csharp\nvar actor = Sys.ActorOf(Props.Create<Foo>().WithDispatcher(\"myapp.my-forkjoin-dispatcher\"));\n```\nFluentConfiguration [REMOVED]**\n`FluentConfig` has been removed as we've decided to standardize on HOCON configuration, but if you still want to use the old FluentConfig bits you can find them here: https://github.com/rogeralsing/Akka.FluentConfig\nF# API**\nThe F# API has changed to reflect the other C# interface changes, as well as unique additions specific to F#.\nIn addition to updating the F# API, we've also fixed a long-standing bug with being able to serialize discriminated unions over the wire. This has been resolved.\nInterface Renames**\nIn order to comply with .NET naming conventions and standards, all of the following interfaces have been renamed with the `I{InterfaceName}` prefix.\nThe following interfaces have all been renamed to include the `I` prefix:\n- [X] `Akka.Actor.ActorRefProvider, Akka` (Public)\n- [X] `Akka.Actor.ActorRefScope, Akka` (Public)\n- [X] `Akka.Actor.AutoReceivedMessage, Akka` (Public)\n- [X] `Akka.Actor.Cell, Akka` (Public)\n- [X] `Akka.Actor.Inboxable, Akka` (Public)\n- [X] `Akka.Actor.IndirectActorProducer, Akka` (Public)\n- [X] `Akka.Actor.Internal.ChildrenContainer, Akka` (Public)\n- [X] `Akka.Actor.Internal.ChildStats, Akka` (Public)\n- [X] `Akka.Actor.Internal.InternalSupportsTestFSMRef`2, Akka` (Public)\n- [X] `Akka.Actor.Internal.SuspendReason+WaitingForChildren, Akka`\n- [X] `Akka.Actor.Internals.InitializableActor, Akka` (Public)\n- [X] `Akka.Actor.LocalRef, Akka`\n- [X] `Akka.Actor.LoggingFSM, Akka` (Public)\n- [X] `Akka.Actor.NoSerializationVerificationNeeded, Akka` (Public)\n- [X] `Akka.Actor.PossiblyHarmful, Akka` (Public)\n- [X] `Akka.Actor.RepointableRef, Akka` (Public)\n- [X] `Akka.Actor.WithBoundedStash, Akka` (Public)\n- [X] `Akka.Actor.WithUnboundedStash, Akka` (Public)\n- [X] `Akka.Dispatch.BlockingMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.BoundedDequeBasedMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.BoundedMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.DequeBasedMailbox, Akka` (Public)\n- [X] `Akka.Dispatch.DequeBasedMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.MessageQueues.MessageQueue, Akka` (Public)\n- [X] `Akka.Dispatch.MultipleConsumerSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.RequiresMessageQueue`1, Akka` (Public)\n- [X] `Akka.Dispatch.Semantics, Akka` (Public)\n- [X] `Akka.Dispatch.SysMsg.SystemMessage, Akka` (Public)\n- [X] `Akka.Dispatch.UnboundedDequeBasedMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Dispatch.UnboundedMessageQueueSemantics, Akka` (Public)\n- [X] `Akka.Event.LoggingAdapter, Akka` (Public)\n- [X] `Akka.FluentConfigInternals, Akka` (Public)\n- [X] `Akka.Remote.InboundMessageDispatcher, Akka.Remote`\n- [X] `Akka.Remote.RemoteRef, Akka.Remote`\n- [X] `Akka.Routing.ConsistentHashable, Akka` (Public)\n`ConsistentHashRouter` and `IConsistentHashable`**\nAkka.NET v1.0 introduces the idea of virtual nodes to the `ConsistentHashRouter`, which are designed to provide more even distributions of hash ranges across a relatively small number of routees. You can take advantage of virtual nodes via configuration:\n```xml\nakka.actor.deployment {\n\t/router1 {\n\t\trouter = consistent-hashing-pool\n\t\tnr-of-instances = 3\n\t\tvirtual-nodes-factor = 17\n\t}\n}\n```\nOr via code:\n```csharp\nvar router4 = Sys.ActorOf(Props.Empty.WithRouter(\n\tnew ConsistentHashingGroup(new[]{c},hashMapping: hashMapping)\n\t.WithVirtualNodesFactor(5)),\n\t\"router4\");\n```\n`ConsistentHashMapping` Delegate**\nThere are three ways to instruct a router to hash a message:\n1. Wrap the message in a `ConsistentHashableEnvelope`;\n2. Implement the `IConsistentHashable` interface on your message types; or\n3. Or, write a `ConsistentHashMapper` delegate and pass it to a `ConsistentHashingGroup` or a `ConsistentHashingPool` programmatically at create time.\nHere's an example, taken from the `ConsistentHashSpecs`:\n```csharp\nConsistentHashMapping hashMapping = msg =>\n{\nif (msg is Msg2)\n{\nvar m2 = msg as Msg2;\nreturn m2.Key;\n}\nreturn null;\n};\nvar router2 =\nSys.ActorOf(new ConsistentHashingPool(1, null, null, null, hashMapping: hashMapping)\n.Props(Props.Create<Echo>()), \"router2\");\n```\nAlternatively, you don't have to pass the `ConsistentHashMapping` into the constructor - you can use the `WithHashMapping` fluent interface built on top of both `ConsistentHashingGroup` and `ConsistentHashingPool`:\n```csharp\nvar router2 =\nSys.ActorOf(new ConsistentHashingPool(1).WithHashMapping(hashMapping)\n.Props(Props.Create<Echo>()), \"router2\");\n```\n`ConsistentHashable` renamed to `IConsistentHashable`**\nAny objects you may have decorated with the `ConsistentHashable` interface to work with `ConsistentHashRouter` instances will need to implement `IConsistentHashable` going forward, as all interfaces have been renamed with the `I-` prefix per .NET naming conventions.\nAkka.DI.Unity NuGet Package**\nAkka.NET now ships with dependency injection support for [Unity](http://unity.codeplex.com/).\nYou can install our Unity package via the following command in the NuGet package manager console:\n```\nPM> Install-Package Akka.DI.Unity\n```\n----",
  "requireLicenseAcceptance": false,
  "title": "Akka.DI.CastleWindsor",
  "verbatimVersion": "1.0.0",
  "version": "1.0.0",
  "dependencyGroups": [
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#dependencygroup",
      "@type": "PackageDependencyGroup",
      "dependencies": [
        {
          "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#dependencygroup/castle.core",
          "@type": "PackageDependency",
          "id": "Castle.Core",
          "range": "[3.3.0, )"
        },
        {
          "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#dependencygroup/castle.windsor",
          "@type": "PackageDependency",
          "id": "Castle.Windsor",
          "range": "[3.3.0, )"
        },
        {
          "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#dependencygroup/akka.di.core",
          "@type": "PackageDependency",
          "id": "Akka.DI.Core",
          "range": "[1.0.0, )"
        }
      ]
    }
  ],
  "packageEntries": [
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#Akka.DI.CastleWindsor.nuspec",
      "@type": "PackageEntry",
      "compressedLength": 4992,
      "fullName": "Akka.DI.CastleWindsor.nuspec",
      "length": 13826,
      "name": "Akka.DI.CastleWindsor.nuspec"
    },
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#lib/net45/Akka.DI.CastleWindsor.dll",
      "@type": "PackageEntry",
      "compressedLength": 3353,
      "fullName": "lib/net45/Akka.DI.CastleWindsor.dll",
      "length": 7680,
      "name": "Akka.DI.CastleWindsor.dll"
    },
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#lib/net45/Akka.DI.CastleWindsor.xml",
      "@type": "PackageEntry",
      "compressedLength": 577,
      "fullName": "lib/net45/Akka.DI.CastleWindsor.xml",
      "length": 2080,
      "name": "Akka.DI.CastleWindsor.xml"
    },
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2022.12.16.13.12.37/akka.di.castlewindsor.1.0.0.json#.signature.p7s",
      "@type": "PackageEntry",
      "compressedLength": 9461,
      "fullName": ".signature.p7s",
      "length": 9461,
      "name": ".signature.p7s"
    }
  ],
  "tags": [
    "akka",
    "actors",
    "actor",
    "model",
    "Akka",
    "concurrency",
    "DI",
    "CastleWindsor"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "packageTypes": {
      "@id": "packageType",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "vulnerabilities": {
      "@id": "vulnerability",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    },
    "reasons": {
      "@container": "@set"
    }
  }
}