{
  "@id": "https://api.nuget.org/v3/catalog0/data/2019.04.23.13.19.29/expresswalker.core.2.1.0.json",
  "@type": [
    "PackageDetails",
    "catalog:Permalink"
  ],
  "authors": "Ivan Kopcanski",
  "catalog:commitId": "3c1fe560-edfe-453c-aaf5-6504723c8e46",
  "catalog:commitTimeStamp": "2019-04-23T13:19:29.6957083Z",
  "copyright": "Ivan Kopcanski 2019",
  "created": "2019-04-23T13:15:04.46Z",
  "description": "ExpressWalker provides a generic way to examine and change any object graph in fashion similar to \"Visitor Pattern\". You can build generic hierarchy composition (visitor) that can visit and change any object's property, basing on configuration. Relies on expression trees while visiting objects (uses reflection only once while building a visitor). That's why IT IS WAY FASTER than custom solutions built with reflection.\nIt is protected from circular references so you can avoid exceptions. Provides fluent API which increases code readability in terms of guessing the hierarchy being built from the code. Some of functionalities: visiting properties by matching owner type, property name and type (or only property type), visiting collecitons and dictionary items, specifying depth, custom expression for changing property value, cloning etc.\n\t\n//example 1 - IVisitor that visits properties by ownner type and property names and/or types (start from TypeWalker class):\n\n  var typeVisitor = TypeWalker<Parent>.Create()\n                  .ForProperty<Parent, string>(p => p.TestString1, (old, met) => old + met)\n                  .ForProperty<Child, DateTime>(p => p.TestDate1, (old, met) => old.AddYears(10))\n                  .ForProperty<CommonType>((old, met) => new CommonType { CommonString = \"...\" })\n                  .Build(depth:10, guard:new PropertyGuard(), supportsCloning: true);\n\t\t\t\t  \n\t//guard is protection against type-wise circular references. supportsCloning = false improves build time.\n\t\t\t\t  \n  var parentClone = new Parent();\n  var propertyValues = new HashSet<PropertyValue>()\n  typeVisitor.Visit(parentObject, parentClone, depth:10, guard:new InstanceGuard(), values:propertyValues); \n\n\t//guard is protection against instance-wise circular references. values will hold flat list of new/old values.\n  \n//example 2 - IVisitor that visits properties by explicit configuration (start from ManualWalker class):\n\n  var manualVisitor = ManualWalker.Create<A1>()\n                                    .Property<A1, DateTime>(a1 => a1.A1Date, (va1, met) => va1.AddYears(10))\n                                    .Element<A1, B1>(a1 => a1.B1, b1 =>\n                                            b1.Property<B1, string>(x => x.B1Name, (vb1, met) => vb1 + \"Test2\"))\n                                    .Collection<A1, B2>(a1 => a1.B2List, b2 => b2\n                                            .Property<B2, DateTime>(x => x.B2Date, (vb2, met) => vb2.AddYears(10)))\n                                .Build();\n\n  manualVisitor.Visit(parentObject, blueprint:null, depth:10, guard:new InstanceGuard(), values:null);\n\t\t\t\n//Paremeter 'met' in expressions above is optional metadata object set in design-time. \n//It can be set by [VisitorMetadata] property attribute in visited class.\n//e.g. in example above, there is [VisitorMetadata(\"AnyString\")] on property Parent.TestString1.\n\n//example 3 - IVisitor built and cached using the IVisitorsFactory:\n//scenario for visitors of same settings built for different types:\n  \n  var factory = new VisitorsFactory().WithSettings(\"name1\", depth:5, usePropertyGuard:false, supportsCloning:false)\n                                       .ForProperty<int>((val, met) => 2)\n                                     .WithSettings(\"name6\")\n                                       .ForProperty<Parent, string>( x => x.Name, (val, met) => \"t\");\n\t\t\t\t\t\t\t\t\t \n  var visitor1 = factory.GetVisitor(\"name1\", typeof(Class1));\n  var visitor1a = factory.GetVisitor(\"name1\", typeof(Class1));\n  var visitor2 = factory.GetVisitor(\"name1\", typeof(Class2));\n  var visitor6 = factory.GetVisitor(\"name6\", typeof(Class6));\n  \n//visitor1 == visitor1a --true\n//visitor1 == visitor2 --false\t \n\nMany thanks to Francisco Jos√© Rey Gozalo for contributing with ideas and solutions.\nRead more on https://github.com/kopalite/ExpressWalker",
  "frameworkAssemblyGroup": {
    "@id": "https://api.nuget.org/v3/catalog0/data/2019.04.23.13.19.29/expresswalker.core.2.1.0.json#frameworkassemblygroup",
    "assembly": [
      "System",
      "System.Core",
      "Microsoft.CSharp"
    ]
  },
  "id": "ExpressWalker.Core",
  "isPrerelease": false,
  "language": "en-US",
  "lastEdited": "2019-04-23T13:19:13.97Z",
  "licenseUrl": "https://github.com/kopalite/ExpressWalker.Core/blob/master/LICENSE",
  "listed": true,
  "packageHash": "FPsCx9K7ughi9qQXIqdXs7c59DWuY4HzEb95ftMpCm90fEgPh+JS5+BoCsoL8uGkV8f1RppYPOgWiy4Vq/A6gA==",
  "packageHashAlgorithm": "SHA512",
  "packageSize": 34620,
  "projectUrl": "https://github.com/kopalite/ExpressWalker.Core",
  "published": "2019-04-23T13:15:04.46Z",
  "releaseNotes": "Visiting dictionary values is now supported. IVisitorsFactory can be used for building visitors for many types basing on the same settings. It caches visitors instances and use them as singletons - this will minimize boilerplate code you need to write. [VisitorHierarchy] attribute can be used to mark structures that are build as compositions (hierarchies) - that helps improving visitors build time.",
  "requireLicenseAcceptance": true,
  "summary": "ExpressWalker provides a generic way to examine and change any object graph in fashion similar to \"Visitor Pattern\". You can build generic hierarchy composition (visitor) that can visit and change any object's property, basing on configuration. Relies on expression trees while visiting objects (uses reflection only once while building a visitor).",
  "title": "ExpressWalker.Core",
  "verbatimVersion": "2.1.0",
  "version": "2.1.0",
  "packageEntries": [
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2019.04.23.13.19.29/expresswalker.core.2.1.0.json#ExpressWalker.Core.nuspec",
      "@type": "PackageEntry",
      "compressedLength": 2060,
      "fullName": "ExpressWalker.Core.nuspec",
      "length": 5852,
      "name": "ExpressWalker.Core.nuspec"
    },
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2019.04.23.13.19.29/expresswalker.core.2.1.0.json#lib/netstandard2.0/ExpressWalker.Core.dll",
      "@type": "PackageEntry",
      "compressedLength": 19905,
      "fullName": "lib/netstandard2.0/ExpressWalker.Core.dll",
      "length": 49152,
      "name": "ExpressWalker.Core.dll"
    },
    {
      "@id": "https://api.nuget.org/v3/catalog0/data/2019.04.23.13.19.29/expresswalker.core.2.1.0.json#.signature.p7s",
      "@type": "PackageEntry",
      "compressedLength": 9464,
      "fullName": ".signature.p7s",
      "length": 9464,
      "name": ".signature.p7s"
    }
  ],
  "tags": [
    "ExpressWalker",
    "Expressions",
    "Visitor"
  ],
  "@context": {
    "@vocab": "http://schema.nuget.org/schema#",
    "catalog": "http://schema.nuget.org/catalog#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dependencies": {
      "@id": "dependency",
      "@container": "@set"
    },
    "dependencyGroups": {
      "@id": "dependencyGroup",
      "@container": "@set"
    },
    "packageEntries": {
      "@id": "packageEntry",
      "@container": "@set"
    },
    "supportedFrameworks": {
      "@id": "supportedFramework",
      "@container": "@set"
    },
    "tags": {
      "@id": "tag",
      "@container": "@set"
    },
    "published": {
      "@type": "xsd:dateTime"
    },
    "created": {
      "@type": "xsd:dateTime"
    },
    "lastEdited": {
      "@type": "xsd:dateTime"
    },
    "catalog:commitTimeStamp": {
      "@type": "xsd:dateTime"
    }
  }
}